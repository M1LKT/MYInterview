## 为什么要有事件循环
JavaScript 的执行环境是单线程的，这意味着它一次只能执行一个任务。如果遇到长时间运行的同步代码，会阻塞后续代码的执行。然而，浏览器需要处理用户交互、网络请求等非阻塞的异步操作。为了在单线程环境下实现异步操作，JavaScript 运行时引入了事件循环机制，用于协调异步任务的执行。

## 什么是事件循环机制
浏览器的事件循环可以粗略分为三个部分：调用栈，宏队列，微队列;在执行代码时，同步代码会被加入调用栈并立即执行；异步任务的回调函数则会被加入宏任务队列或微任务队列。

事件循环的执行过程如下：
1. 以“先进后出”（LIFO）的方式执行调用栈中的同步代码。
2. 当调用栈为空时，事件循环会优先清空微任务队列中的所有任务。
3. 微任务队列清空后，执行宏任务队列中的下一个任务。
4. 当前任务执行完毕，浏览器会检查要不要进行渲染（比如影响视觉显示的操作以及 scroll，resize 事件等、具体看浏览器实现），如果要就渲染线程接管
5. 重复2，3，4步骤

可以概括为这样一个过程：
```
完成调用栈中的任务=>全部微队列中的任务=>一个宏队列的任务=>渲染=>全部微队列中的任务=>一个宏队列的任务=>渲染....
```

## 微队列会存放的任务：
**New Promise 是同步执行的，promise.then 里面的回调才是异步的。**
- `Promise` 的回调函数（`then`、`catch`、`finally`）。
- `MutationObserver` 的回调。
- `queueMicrotask` 显式添加的任务。
- `process.nextTick`
## 宏队列中会存放的任务：
- `setTimeout` 的回调。
- `setInterval` 的回调。
- `setImmediate`（仅在 Node.js 中支持）。
- I/O 操作的回调（如文件读取、网络请求等）。
- UI 渲染相关的任务（浏览器环境）。

## 为什么要区分宏队列和微队列：
1. 为了区分任务的粒度，方便浏览器更好的调度执行
2. 实现了优先级，确保某些异步任务不会被低优先级的任务延迟
3. 浏览器通常在两个宏任务之间执行ui渲染，微任务的逻辑可以抢在渲染前完成。